# 回溯算法
[阅读原文](https://www.geeksforgeeks.org/backtracking-algorithms/)

## 什么是回溯
回溯可以被定义为一种通用的算法技术，它考虑搜索所有可能的组合以解决计算问题。






## 什么是回溯算法
回溯是一种算法技术，通过逐步构建解决方案来递归地解决问题，在任何时间点上移除那些无法满足问题约束条件的解决方案（这里的时间是指到达搜索树的任何层所经过的时机）。





## 回溯算法的种类
回溯存在三种类型的问题：
1. 决策问题——在这种情况下，我们寻找可行的解决方案。
2. 优化问题——在这种情况下，我们寻找最佳解决方案。
3. 枚举问题——在这种情况下，我们找到所有可行的解决方案。






## 什么时候可以使用回溯算法？
例如，考虑数独解决问题，我们尝试一个接一个地填充数字。 每当我们发现当前数字不能导致解决方案时，我们将其删除（回溯）并尝试下一个数字。 这比天真的方法（生成所有可能的数字组合，然后一个一个地尝试每个组合）要好，因为它会在回溯时丢弃一组排列。






## 回溯和递归有什么区别
1. 递归并不总是需要回溯，而回溯需要用到递归来解决问题
2. 递归函数通过调用自身的副本并解决原始问题的较小子问题来解决特定问题。而回溯每一步的倒退都会消除那些无法给我们提供解决方案的选择，并继续进行那些有可能带我们找到解决方案的选择。
3. 递归是回溯本身的一部分，编写起来更简单。回溯的实现相对复杂。
4. 递归的应用程序有树和图遍历、河内塔、分治算法、合并排序、快速排序和二进制搜索。回溯的应用是N皇后问题，迷宫中的老鼠问题，骑士之旅问题，数独解算器，和图形着色问题。



## 回溯算法的题目
写回溯算法可能经常会用到一些变量

- backtrack: 回溯函数
- path<any[]>:  在回溯过程中记录走过的路径，**一般作为回溯函数的必传参数**
- option<any[]>:  在回溯过程中提供选择的列表，**一般作为回溯函数的必传参数**
- used<boolean[]>:  在回溯过程中记录枚举的 `options[i]` 是否被选择过，**一般作为回溯函数的可选参数**
- set\<Set>: 在回溯过程中记录枚举的 `options[i]` 是否在同一层曾经枚举过相同的值，**一般是回溯函数内部定义的可选变量**

```js
/* used 可选参数 */ 
function backtrack(path,option,used) {
    if (path.length === option.length) {
        /* do something */
        return;
    } 

    /* 可选， set 用于记录同层 option 是否重复使用 */
    const set = new Set()
    for (let i=0; i<option.length; i++) {

    }

}
```




### 简单
1. []()
2. []()
3. []()
4. []()
5. []()
6. []()
7. []()



### 中等


### 困难

